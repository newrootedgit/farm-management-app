/**
 * Recurring Order Generator Service
 *
 * Automatically generates orders from recurring schedules.
 * Runs on startup and periodically to ensure orders are created ahead of time.
 */

import { PrismaClient } from '@prisma/client';
import {
  calculateRecurringHarvestDates,
  calculateProductionSchedule,
  generateOrderNumber,
} from '@farm/shared';

export interface GeneratorResult {
  schedulesProcessed: number;
  ordersCreated: number;
  errors: string[];
}

/**
 * Generate orders for all active recurring schedules.
 * Creates orders for any upcoming harvest dates that don't already have orders.
 */
export async function generateRecurringOrders(
  prisma: PrismaClient
): Promise<GeneratorResult> {
  const result: GeneratorResult = {
    schedulesProcessed: 0,
    ordersCreated: 0,
    errors: [],
  };

  try {
    // Get all active schedules with their items and skipped dates
    const schedules = await prisma.recurringOrderSchedule.findMany({
      where: {
        isActive: true,
        // Only process schedules that haven't ended
        OR: [
          { endDate: null },
          { endDate: { gte: new Date() } },
        ],
      },
      include: {
        items: {
          include: { product: true },
        },
        skippedDates: {
          where: {
            skipDate: { gte: new Date() },
          },
        },
        customer: true,
      },
    });

    for (const schedule of schedules) {
      result.schedulesProcessed++;

      try {
        // Calculate upcoming harvest dates
        const upcomingDates = calculateRecurringHarvestDates(
          {
            scheduleType: schedule.scheduleType as 'FIXED_DAY' | 'INTERVAL',
            daysOfWeek: schedule.daysOfWeek,
            intervalDays: schedule.intervalDays ?? undefined,
            startDate: schedule.startDate,
            endDate: schedule.endDate,
            leadTimeDays: schedule.leadTimeDays,
          },
          schedule.skippedDates.map((s) => s.skipDate)
        );

        // Get existing orders for this schedule to avoid duplicates
        const existingOrders = await prisma.order.findMany({
          where: {
            recurringScheduleId: schedule.id,
            scheduledHarvestDate: {
              in: upcomingDates,
            },
          },
          select: { scheduledHarvestDate: true },
        });

        const existingDates = new Set(
          existingOrders.map((o) => o.scheduledHarvestDate?.getTime())
        );

        // Create orders for dates that don't have one yet
        for (const harvestDate of upcomingDates) {
          if (existingDates.has(harvestDate.getTime())) {
            continue; // Already exists
          }

          // Generate order
          try {
            const order = await createOrderFromSchedule(
              prisma,
              schedule,
              harvestDate
            );
            if (order) {
              result.ordersCreated++;
            }
          } catch (orderError) {
            result.errors.push(
              `Failed to create order for schedule "${schedule.name}" on ${harvestDate.toISOString()}: ${orderError}`
            );
          }
        }
      } catch (scheduleError) {
        result.errors.push(
          `Failed to process schedule "${schedule.name}": ${scheduleError}`
        );
      }
    }
  } catch (error) {
    result.errors.push(`Generator failed: ${error}`);
  }

  return result;
}

/**
 * Create a single order from a recurring schedule for a specific harvest date.
 */
async function createOrderFromSchedule(
  prisma: PrismaClient,
  schedule: {
    id: string;
    name: string;
    farmId: string;
    customerId: string | null;
    customer: { name: string } | null;
    items: Array<{
      productId: string;
      quantityOz: number;
      overagePercent: number;
      product: {
        id: string;
        name: string;
        avgYieldPerTray: number | null;
        daysSoaking: number | null;
        daysGermination: number | null;
        daysLight: number | null;
      };
    }>;
  },
  harvestDate: Date
) {
  // Generate order number
  const count = await prisma.order.count({ where: { farmId: schedule.farmId } });
  const orderNumber = generateOrderNumber(count + 1);

  // Create order in transaction
  return prisma.$transaction(async (tx) => {
    // Create order
    const newOrder = await tx.order.create({
      data: {
        farmId: schedule.farmId,
        orderNumber,
        customerName: schedule.customer?.name || null,
        customerId: schedule.customerId,
        recurringScheduleId: schedule.id,
        isAutoGenerated: true,
        scheduledHarvestDate: harvestDate,
        notes: `Auto-generated from recurring schedule: ${schedule.name}`,
      },
    });

    // Create items with calculated dates and tasks
    for (const item of schedule.items) {
      const product = item.product;

      // Skip if product doesn't have required fields
      if (product.daysGermination == null || product.daysLight == null) {
        console.warn(
          `Skipping item "${product.name}" - missing production data`
        );
        continue;
      }

      const scheduleCalc = calculateProductionSchedule({
        quantityOz: item.quantityOz,
        avgYieldPerTray: product.avgYieldPerTray || 8,
        overagePercent: item.overagePercent,
        harvestDate,
        daysSoaking: product.daysSoaking,
        daysGermination: product.daysGermination,
        daysLight: product.daysLight,
      });

      const orderItem = await tx.orderItem.create({
        data: {
          orderId: newOrder.id,
          productId: item.productId,
          quantityOz: item.quantityOz,
          harvestDate,
          overagePercent: item.overagePercent,
          traysNeeded: scheduleCalc.traysNeeded,
          soakDate: scheduleCalc.soakDate,
          seedDate: scheduleCalc.seedDate,
          moveToLightDate: scheduleCalc.moveToLightDate,
        },
      });

      // Create tasks
      const tasks: Array<{
        title: string;
        type: 'SOAK' | 'SEED' | 'MOVE_TO_LIGHT' | 'HARVESTING';
        dueDate: Date;
        description: string;
      }> = [];

      if (scheduleCalc.requiresSoaking) {
        tasks.push({
          title: `SOAK: ${product.name}`,
          type: 'SOAK',
          dueDate: scheduleCalc.soakDate,
          description: `Soak ${scheduleCalc.traysNeeded} trays of ${product.name} seeds`,
        });
      }

      tasks.push(
        {
          title: `SEED: ${product.name}`,
          type: 'SEED',
          dueDate: scheduleCalc.seedDate,
          description: `Plant ${scheduleCalc.traysNeeded} trays of ${product.name}`,
        },
        {
          title: `MOVE TO LIGHT: ${product.name}`,
          type: 'MOVE_TO_LIGHT',
          dueDate: scheduleCalc.moveToLightDate,
          description: `Move ${scheduleCalc.traysNeeded} trays of ${product.name} to grow lights`,
        },
        {
          title: `HARVEST: ${product.name}`,
          type: 'HARVESTING',
          dueDate: scheduleCalc.harvestDate,
          description: `Harvest ${item.quantityOz}oz of ${product.name} (${scheduleCalc.traysNeeded} trays)`,
        }
      );

      for (const taskData of tasks) {
        await tx.task.create({
          data: {
            farmId: schedule.farmId,
            orderItemId: orderItem.id,
            title: taskData.title,
            type: taskData.type,
            dueDate: taskData.dueDate,
            description: taskData.description,
            priority: 'MEDIUM',
            status: 'TODO',
          },
        });
      }
    }

    return newOrder;
  });
}

/**
 * Start the recurring order generator on a schedule.
 * Runs immediately on startup, then every hour.
 */
export function startRecurringOrderGenerator(prisma: PrismaClient): void {
  // Run immediately on startup
  console.log('üîÑ Running initial recurring order generation...');
  generateRecurringOrders(prisma).then((result) => {
    console.log(
      `‚úÖ Recurring order generation complete: ${result.ordersCreated} orders created from ${result.schedulesProcessed} schedules`
    );
    if (result.errors.length > 0) {
      console.warn('‚ö†Ô∏è Errors during generation:', result.errors);
    }
  });

  // Run every hour
  const HOUR_MS = 60 * 60 * 1000;
  setInterval(async () => {
    console.log('üîÑ Running scheduled recurring order generation...');
    const result = await generateRecurringOrders(prisma);
    console.log(
      `‚úÖ Recurring order generation complete: ${result.ordersCreated} orders created from ${result.schedulesProcessed} schedules`
    );
    if (result.errors.length > 0) {
      console.warn('‚ö†Ô∏è Errors during generation:', result.errors);
    }
  }, HOUR_MS);
}
